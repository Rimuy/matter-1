[{"title":"Using CollectionService tags","type":0,"sectionRef":"#","url":"docs/BestPractices/CollectionService","content":"Using CollectionService tags As a pure ECS first and foremost, Matter provides no special functionality for CollectionService tags out of the box. However, it's rather simple to implement this yourself. Here's an example taken from the official Matter example game. local boundTags = { Spinner = Components.Spinner, } local function spawnBound(instance, component) local id = world:spawn( component(), Components.Bind({ instance = instance, }), Components.Transform({ cframe = instance.CFrame, }) ) instance:SetAttribute(&quot;entityId&quot;, id) end for tagName, component in pairs(boundTags) do for _, instance in ipairs(CollectionService:GetTagged(tagName)) do spawnBound(instance, component) end CollectionService:GetInstanceAddedSignal(tagName):Connect(function(instance) spawnBound(instance, component) end) CollectionService:GetInstanceRemovedSignal(tagName):Connect(function(instance) local id = instance:GetAttribute(&quot;entityId&quot;) if id then world:despawn(id) end end) end This example can be modified to meet your game's needs as you see fit.","keywords":""},{"title":"Matter","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Goals​","type":1,"pageTitle":"Matter","url":"docs/intro#goals","content":"Simple, obvious APIPerformantGreat debuggability, error handling and insight into what's actually happening each frameCommon patterns are easy to fall into and hard to mess up "},{"title":"Non-goals​","type":1,"pageTitle":"Matter","url":"docs/intro#non-goals","content":"Many similar libraries, ECS or not, end up with a bloated API, requiring significant cognitive overhead to use. We want to avoid this as much as possible.We don't want to provide every thing the user could ever want in our library. Instead, it should be easy for users to write obvious code that does those things. "},{"title":"Performance today​","type":1,"pageTitle":"Matter","url":"docs/intro#performance-today","content":"Matter currently achieves an average frame time of 0.65ms spent inside Matter code for the following benchmark: World with 1000 entitiesBetween 2-30 components on each entity300 unique component types200 systemsEach system queries between 1 and 10 components "},{"title":"Prior art​","type":1,"pageTitle":"Matter","url":"docs/intro#prior-art","content":"Matter is inspired by hecs by Railith from the Rust ecosystem! "},{"title":"Why ECS","type":0,"sectionRef":"#","url":"docs/WhyECS","content":"Why ECS Behavior is declarative. Systems run every frame, and declare what the state of the world should be right now. This makes code self-healing and more resilient to game-breaking bugs than in an event-driven model where reacting to something happening only happens once.Game state and behavior are entirely decoupled and all game state is accessible to any system.Game state is structured and easy to reason about. We reconcile state into the data model so we have one source of truth.Systems are self-contained and new adding behaviors to your game is as simple as adding a new system that declares something about how the world should be.Reusing code is easy because an entity can have many different types of components. Existing systems can affect new types of entities, and new systems automatically affect all related entities.All system code runs contiguously and in a fixed order, every frame. Event-driven code can be sensitive to ordering, because doing anything can trigger an event that jumps into another code path, which in turn could do something else that triggers an event. With systems, your code always runs in the same, fixed order, which makes it much more predictable and resilient to new behaviors caused from refactors.","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"docs/Installation","content":"","keywords":""},{"title":"Wally package manager​","type":1,"pageTitle":"Installation","url":"docs/Installation#wally-package-manager","content":"Install Wally with Foreman. foreman.toml wally = { source = &quot;UpliftGames/wally&quot;, version = &quot;0.3.1&quot; }  If you don't have a wally.toml file, run wally init.Add matter under [dependencies]. Copy the latest version from this page. wally.toml [package] name = &quot;biff/package&quot; version = &quot;0.1.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] matter = &quot;evaera/matter@X.X.X&quot; # Don't copy this. This won't work. # Copy real string from page linked above.  Run wally install.Sync in the Packages folder with Rojo. "},{"title":"Manual​","type":1,"pageTitle":"Installation","url":"docs/Installation#manual","content":"Download matter.rbxm from the latest release.Sync in with Rojo or import into Roblox Studio manually. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/GettingStarted","content":"","keywords":""},{"title":"Next steps​","type":1,"pageTitle":"Getting Started","url":"docs/GettingStarted#next-steps","content":"You should dive in to the API reference! The Matter API is simple and documented in detail. A more detailed usage guide will be written eventually, offering an introduction to ECS architecture and going over more of Matter's design philosophy. "},{"title":"Component","type":0,"sectionRef":"#","url":"api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"api/Component#types","content":" "},{"title":"ComponentInstance​","type":1,"pageTitle":"Component","url":"api/Component#ComponentInstance","content":"&lt;/&gt; type ComponentInstance = {} The ComponentInstance type refers to an actual piece of data that can exist on an entity. The metatable of the component instance table is set to its particular Component table. A component instance can be created by calling the Component table: -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; }) print(getmetatable(myComponentInstance) == MyComponent) --&gt; true  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"api/Component#functions","content":" "},{"title":"patch​","type":1,"pageTitle":"Component","url":"api/Component#patch","content":"&lt;/&gt; Component:patch( partialNewData: {}-- The table to be merged with the existing component data. ) → ComponentInstance-- A copy of the component instance with values from partialNewData overriding existing values. for id, target in world:query(Target) do if shouldChangeTarget(target) then world:insert(id, target:patch({ -- modify the existing component currentTarget = getNewTarget() })) end end A utility function used to immutably modify an existing component instance. Key/value pairs from the passed table will override those of the existing component instance. As all components are immutable and frozen, it is not possible to modify the existing component directly. You can use the Matter.None constant to remove a value from the component instance: target:patch({ currentTarget = Matter.None -- sets currentTarget to nil })  "},{"title":"QueryResult","type":0,"sectionRef":"#","url":"api/QueryResult","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#functions","content":" "},{"title":"next​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#next","content":"&lt;/&gt; QueryResult:next() → ( id,-- Entity ID ...ComponentInstance-- The requested component values ) Returns the next set of values from the query result. Once all results have been returned, the QueryResult is exhausted and is no longer useful. info This function is equivalent to calling the QueryResult as a function. When used in a for loop, this is implicitly done by the language itself. -- Using world:query in this position will make Lua invoke the table as a function. This is conventional. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end If you wanted to iterate over the QueryResult without a for loop, it's recommended that you call next directly instead of calling the QueryResult as a function. local id, enemy, charge, model = world:query(Enemy, Charge, Model):next() local id, enemy, charge, model = world:query(Enemy, Charge, Model)() -- Possible, but unconventional   "},{"title":"snapshot​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#snapshot","content":"&lt;/&gt; QueryResult:snapshot() → {{ entityId: number, component: ComponentInstance, component: ComponentInstance, component: ComponentInstance, ... }} Creates a &quot;snapshot&quot; of this query, draining this QueryResult and returning a list containing all of its results. By default, iterating over a QueryResult happens in &quot;real time&quot;: it iterates over the actual data in the ECS, so changes that occur during the iteration will affect future results. By contrast, QueryResult:snapshot() creates a list of all of the results of this query at the moment it is called, so changes made while iterating over the result of QueryResult:snapshot do not affect future results of the iteration. Of course, this comes with a cost: we must allocate a new list and iterate over everything returned from the QueryResult in advance, so using this method is slower than iterating over a QueryResult directly. The table returned from this method has a custom __iter method, which lets you use it as you would use QueryResult directly: for entityId, health, player in world:query(Health, Player):snapshot() do end However, the table itself is just a list of sub-tables structured like {entityId, component1, component2, ...etc}.  "},{"title":"without​","type":1,"pageTitle":"QueryResult","url":"api/QueryResult#without","content":"&lt;/&gt; QueryResult:without( ...: Component-- The component types to filter against. ) → () → ( id, ...ComponentInstance )-- Iterator of entity ID followed by the requested component values Returns an iterator that will skip any entities that also have the given components. tip This is essentially equivalent to querying normally, using World:get to check if a component is present, and using Lua's continue keyword to skip this iteration (though, using :without is faster). This means that you should avoid queries that return a very large amount of results only to filter them down to a few with :without. If you can, always prefer adding components and making your query more specific. for id in world:query(Target):without(Model) do -- Do something end  "},{"title":"Matter","type":0,"sectionRef":"#","url":"api/Matter","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Matter","url":"api/Matter#properties","content":" "},{"title":"World​","type":1,"pageTitle":"Matter","url":"api/Matter#World","content":"&lt;/&gt; Matter.World: World   "},{"title":"Loop​","type":1,"pageTitle":"Matter","url":"api/Matter#Loop","content":"&lt;/&gt; Matter.Loop: Loop   "},{"title":"None​","type":1,"pageTitle":"Matter","url":"api/Matter#None","content":"&lt;/&gt; Matter.None: None A value should be interpreted as nil when merging dictionaries. Matter.None is used by Component:patch. "},{"title":"Functions​","type":1,"pageTitle":"Matter","url":"api/Matter#functions","content":" "},{"title":"useDeltaTime​","type":1,"pageTitle":"Matter","url":"api/Matter#useDeltaTime","content":"&lt;/&gt; Matter.useDeltaTime() → number  Topologically-aware function This function is only usable if called within the context of Loop:begin. Returns the os.clock() time delta between the start of this and last frame.  "},{"title":"useEvent​","type":1,"pageTitle":"Matter","url":"api/Matter#useEvent","content":"&lt;/&gt; Matter.useEvent( instance: Instance ,-- The instance that has the event you want to connect to event: string | RBXScriptSignal -- The name of or actual event that you want to connect to ) → () → ( number, ...any )  Topologically-aware function This function is only usable if called within the context of Loop:begin. Collects events that fire during the frame and allows iteration over event arguments. for _, player in ipairs(Players:GetPlayers()) do for i, character in useEvent(player, &quot;CharacterAdded&quot;) do world:spawn( Components.Target(), Components.Model({ model = character, }) ) end end Returns an iterator function that returns an ever-increasing number, starting at 1, followed by any event arguments from the specified event. Events are returned in the order that they were fired. caution useEvent keys storage uniquely identified by the script and line number useEvent was called from, and the first parameter (instance). If the second parameter, event, is not equal to the event passed in for this unique storage last frame, the old event is disconnected from and the new one is connected in its place. Tl;dr: on a given line, you should hard-code a single event to connect to. Do not dynamically change the event with a variable. Dynamically changing the first parameter (instance) is fine. for _, instance in pairs(someTable) do for i, arg1, arg2 in useEvent(instance, &quot;Touched&quot;) do -- This is ok end end for _, instance in pairs(someTable) do local event = getEventSomehow() for i, arg1, arg2 in useEvent(instance, event) do -- PANIC! This is NOT OK end end If useEvent ceases to be called on the same line with the same instance and event, the event connection is disconnected from automatically. You can also pass the actual event object instead of its name as the second parameter: useEvent(instance, instance.Touched) useEvent(instance, instance:GetPropertyChangedSignal(&quot;Name&quot;))   "},{"title":"useThrottle​","type":1,"pageTitle":"Matter","url":"api/Matter#useThrottle","content":"&lt;/&gt; Matter.useThrottle( seconds: number,-- The number of seconds to throttle for discriminator?: any-- A unique value to additionally key by ) → boolean-- returns true every x seconds, otherwise false  Topologically-aware function This function is only usable if called within the context of Loop:begin. Utility for easy time-based throttling. Accepts a duration, and returns true if it has been that long since the last time this function returned true. Always returns true the first time. This function returns unique results keyed by script and line number. Additionally, uniqueness can be keyed by a unique value, which is passed as a second parameter. This is useful when iterating over a query result, as you can throttle doing something to each entity individually. if useThrottle(1) then -- Keyed by script and line number only print(&quot;only prints every second&quot;) end for id, enemy in world:query(Enemy) do if useThrottle(5, id) then -- Keyed by script, line number, and the entity id print(&quot;Recalculate target...&quot;) end end   "},{"title":"component​","type":1,"pageTitle":"Matter","url":"api/Matter#component","content":"&lt;/&gt; Matter.component( name?: string,-- Optional name for debugging purposes defaultData?: {}-- Default data that will be merged with data passed to the component when created ) → Component-- Your new type of component Creates a new type of component. Call the component as a function to create an instance of that component. If defaultData is specified, it will be merged with data passed to the component when the component instance is created. Note that this is not fallback data: if you later remove a field from a component instance that is specified in the default data, it won't fall back to the value specified in default data. -- Component: local MyComponent = Matter.component(&quot;My component&quot;) -- component instance: local myComponentInstance = MyComponent({ some = &quot;data&quot; })   "},{"title":"useHookState​","type":1,"pageTitle":"Matter","url":"api/Matter#useHookState","content":"&lt;/&gt; Matter.useHookState( discriminator?: any,-- A unique value to additionally key by cleanupCallback: (storage: {}) → boolean?-- A function to run when the storage for this hook is cleaned up ) → {}  tip Don't use this function directly in your systems. This function is used for implementing your own topologically-aware functions. It should not be used in your systems directly. You should use this function to implement your own utilities, similar to useEvent and useThrottle. useHookState does one thing: it returns a table. An empty, pristine table. Here's the cool thing though: it always returns the same table, based on the script and line where your function (the function calling useHookState) was called. Uniqueness If your function is called multiple times from the same line, perhaps within a loop, the default behavior ofuseHookState is to uniquely identify these by call count, and will return a unique table for each call. However, you can override this behavior: you can choose to key by any other value. This means that in addition to script and line number, the storage will also only return the same table if the unique value (otherwise known as the &quot;discriminator&quot;) is the same. Cleaning up As a second optional parameter, you can pass a function that is automatically invoked when your storage is about to be cleaned up. This happens when your function (and by extension, useHookState) ceases to be called again next frame (keyed by script, line number, and discriminator). Your cleanup callback is passed the storage table that's about to be cleaned up. You can then perform cleanup work, like disconnecting events. Or, you could return true, and abort cleaning up altogether. If you abort cleanup, your storage will stick around another frame (even if your function wasn't called again). This can be used when you know that the user will (or might) eventually call your function again, even if they didn't this frame. (For example, caching a value for a number of seconds). If cleanup is aborted, your cleanup function will continue to be called every frame, until you don't abort cleanup, or the user actually calls your function again. Example: useThrottle This is the entire implementation of the built-in useThrottle function: local function cleanup(storage) return os.clock() &lt; storage.expiry end local function useThrottle(seconds, discriminator) local storage = useHookState(discriminator, cleanup) if storage.time == nil or os.clock() - storage.time &gt;= seconds then storage.time = os.clock() storage.expiry = os.clock() + seconds return true end return false end A lot of talk for something so simple, right? "},{"title":"Reconciliation","type":0,"sectionRef":"#","url":"docs/BestPractices/Reconciliation","content":"","keywords":""},{"title":"The Data Model​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#the-data-model","content":"In Roblox, the Data Model is the tree of instances which embodies all the things in your game. In Lua, the game global is assigned to the root of this tree, whose class is DataModel. The Data Model is also sometimes called the DOM (Document Object Model), a term borrowed from the Web world. When making a game on Roblox, whether a conscious decision or not, the source of truth for game state lives in either in some Lua data structure (e.g., a table), or in the Data Model itself. As an example, the Humanoid object has a Health field. Most games on Roblox use the Humanoid's Health field as the source of truth for players. Thus, the source of truth for player health lives in the Data Model. On the other hand, imagine in your game players can earn points by completing objectives. You create a table which maps players to the number of points they have (e.g., {[Player]: number}). To display the points to the player, you update some text in the game every time the points change. This is an example of the source of truth living in your own code: the points map is the source of truth, and you update the DataModel to reflect this. Many games use a mix of these two ideas for different pieces of state. While this can work, it can lead to problems down the line. Largely, these problems are caused by the instances and properties available in the DataModel being unable to adequately represent complex game state in a convenient way. Developers are forced to contort their game state around what's available in the DataModel, which makes code difficult to reason about. Attributes are an attempt to help solve this problem, but ultimately fall short due to design limitations. You cannot create an attribute with a complex data structure, only primitive values are allowed. And, attributes must be placed on existing instance types, which hamstrings the developer's ability to have control over the state of their own game. Code becomes simpler to reason about if we instead treat Instances and the Data Model as a sort of intermediate representation of our game's state, which is only derived from our true game state: some data structure (e.g., tables) that we keep in Lua. This is what the ECS world is: it's a place where you can structure your game state however you want, optimized for fast batch operations. There are other approaches to storing game state (e.g. object-oriented classes and encapsulation), but this is an ECS library, so that's what we'll focus on. "},{"title":"Reconciliation​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#reconciliation-1","content":"Reconciliation, in this context, means taking state from one form and turning it into another. In our case, we want to reconcile our Lua state into Instances in the Data Model, so that users can see and interact with it. A key idea and benefit of reconciliation is that it's possible to reconcile the same state in multiple different ways. If we have enemies in our world at certain positions, we can reconcile them into the world with character models, but also onto a minimap with red blips. It's the same state being converted into two different ways to view the data. When writing code in an ECS like Matter, it's ideal for all of our gameplay code to operate on the ECS world alone. In the Matter example game, for example, there are ships that fly to certain points in space. For example, instead of updating the ships in the Data Model directly, we store the current goal position in the Ship component. The Ship component knows nothing about the Data Model. It has no reference to the physical ship Instance in the Data Model, it only contains the state about the ship. We can create another component (in the Matter example game, we call it Model) that holds a reference to the ship Instance. We can loop over all Ships that don't also have a Model, and create one for it. ships.lua for id, ship in world:query(Ship):without(Model) do local model = prefabs.Ship:Clone() -- assuming prefabs is a place where you store pre-made models model.Parent = workspace world:insert(id, Model({ instance = model })) end  Now, whenever there's an entity with Ship without Model, we create the model and insert the Model component. We can then loop over all Ships that have Models, and update the position of the Model. ships.lua for id, ship, model in world:query(Ship, Model) do model.instance.BodyPosition.Position = ship.goalPosition end  Keep in mind, both of these loops are performed every frame - that's what a system does. This means that in order to create a Ship from some other system, we need only spawn an entity with Ship - this system we just wrote takes care of creating and further reconciling the state of the Ship into the Data Model. We have a problem now, though: whenever an entity with both Ship and Model is despawned, the physical ship Instance in the Data Model will stick around. Since the Model component is generic and could be reused with any other component (it's not specific to just Ship), we can create another system that handles this case for anything that uses Model. removeModels.lua for _id, modelRecord in world:queryChanged(Model) do if modelRecord.new == nil then if modelRecord.old and modelRecord.old.instance then modelRecord.old.instance:Destroy() end end end  Here, we use queryChanged to loop over Model components that have changed in the last frame. queryChanged gives us a ChangeRecord type, which is a table with old and new properties. If there was an old instance, but no new instance, we know that the Model component has been removed. This can happen when the Model component is removed but the entity still exists (e.g., world:remove(entityId, Model) and also when the entire entity is despawned (e.g., world:despawn(entityId)). We then call Instance:Destroy() on the Instance. Now that we've written this code once for our game, it will operate on any entity that has a Model component. This means that calling world:despawn on an entity with Ship and Model will result in the physical Instance also being removed. "},{"title":"Reverse bindings​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#reverse-bindings","content":""},{"title":"Events​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#events","content":"While we generally want our state to flow in one direction (Lua into the DataModel), we must also be able to interact with the things we've created. Roblox Instances have events that fire, (e.g., Touched) which are still things we need to use. As an example, let's say we wanted the Ship to despawn if it was touched by anything. We can use Matter's useEvent utility to collect events that fire in a frame and loop over them. ships.lua for id, model in world:query(Model, Ship) do for _ in Matter.useEvent(model.Instance, &quot;Touched&quot;) do world:despawn(id) end end  "},{"title":"Removal​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#removal","content":"Sometimes, instances can be removed from the Data Model or destroyed without us doing it. A common cause of this is because parts that are affected by physics fall below the world or get flung to infinity. This can result in those instances being removed without us doing so. To account for this, we can simply loop over every Model and check if it's still in the world. If not, we can either remove the Model component or despawn the entire entity (whichever makes more sense for your game). removeModels.lua for id, model in world:query(Model) do if model.instance:IsDescendantOf(game) == false then world:remove(id, Model) end end  As a side effect, the above code makes it so manually deleting an Instance in a play test in Studio will cause it to be instantly recreated in the same place. This may or may not be the behavior that you want, but it sure is interesting! It should be noted that this method can cause an infinite loop of a Model being created and destroyed if the last Transform was at an invalid position. This can be solved by either just despawning the entire entity instead, or taking care to reset Transform to a known-safe position when removing models. "},{"title":"Two-way bindings​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#two-way-bindings","content":"Imagine we had a component that held the position and rotation of something. This is often called Transform. Our Transform component would hold a CFrame value. There are two potential ways we could want to use this component: We want to update our Transform component and have the physical Instance be moved to that place.We want the Transform component to be updated based on where the Instance is in the world, because physics can move it around. We can make a system that handles both of these cases for us. updateTransforms.lua -- Handle Transform added/changed to existing entity with Model for _id, transformRecord, model in world:queryChanged(Transform, Model) do -- Take care to ignore the changed event if it was us that triggered it if transformRecord.new and not transformRecord.new.doNotReconcile then model.instance:SetPrimaryPartCFrame(transformRecord.new.cframe) end end -- Handle Model added/changed on existing entity with Transform for _id, modelRecord, transform in world:queryChanged(Model, Transform) do if modelRecord.new then modelRecord.new.model:SetPrimaryPartCFrame(transform.cframe) end end -- Update Transform on unanchored Models for id, model, transform in world:query(Model, Transform) do if model.instance.PrimaryPart.Anchored then continue end local existingCFrame = transform.cframe local currentCFrame = model.instance.PrimaryPart.CFrame -- Only insert if actual position is different from the Transform component if currentCFrame ~= existingCFrame then world:insert( id, Components.Transform({ cframe = currentCFrame, doNotReconcile = true, }) ) end end  The above system handles the following cases: When the Transform component is inserted on an entity that also has Model, move the Model to that position.*When the Model component is inserted on an entity that also has Transform, move the Model to that position.When an unanchored Model moves, update the Transform component to match its new position. * We only update the Transform component if it wasn't us that caused it to move. "},{"title":"Benefits of reconciliation​","type":1,"pageTitle":"Reconciliation","url":"docs/BestPractices/Reconciliation#benefits-of-reconciliation","content":"When we structure our game code in this manner, it allows us to do some cool things. For example: Creating a new entity (like a ship) from other systems is as simple as just spawning an entity with a Ship component. We don't have to worry about creating the model for it, because the ship system will look for Ships without Models and make them for us.Likewise, despawning an entity does what we expect. We can just despawn it from any system, and our generic model system will handle cleaning up the model.We don't need to access the Model component of a ship to know where it is in the world, we only need to read the Transform component, even if it's affected by physics. Likewise, to move a ship, we only need to write to (insert) the Transform component.We could copy the entire ECS world at a given point in time, since it's just plain-old data1, and then restore it later. Our systems won't know the difference: models that didn't exist and now do will be created, models that exist now but didn't before will be destroyed, and models that still exist will snap into the correct position.We can reconcile the same state multiple times into the world, like marking ships on a minimap. If saving the data, we would need to take special care to serialize things like CFrame values and Vector3 into JSON-compatible data, but that's beyond the scope of this article↩ "},{"title":"Loop","type":0,"sectionRef":"#","url":"api/Loop","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Loop","url":"api/Loop#types","content":" "},{"title":"System​","type":1,"pageTitle":"Loop","url":"api/Loop#System","content":"&lt;/&gt; type System = SystemTable | (...any) → () Either a plain function or a table defining the system.  "},{"title":"SystemTable​","type":1,"pageTitle":"Loop","url":"api/Loop#SystemTable","content":"&lt;/&gt; interface SystemTable { system: (...any) → ()-- The system function event?: string-- The event the system runs on. A string, a key from the table you pass to Loop:begin. priority?: number-- Priority influences the position in the frame the system is scheduled to run at. after?: {System}-- A list of systems that this system must run after. } A table defining a system with possible options. Systems are scheduled in order of priority, meaning lower priority runs first. The default priority is 0. "},{"title":"Functions​","type":1,"pageTitle":"Loop","url":"api/Loop#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Loop","url":"api/Loop#new","content":"&lt;/&gt; Loop.new( ...: ...any-- Values that will be passed to all of your systems ) → Loop Creates a new loop. Loop.new accepts as arguments the values that will be passed to all of your systems. So typically, you want to pass the World in here, as well as maybe a table of global game state. local world = World.new() local gameState = {} local loop = Loop.new(world, gameState)   "},{"title":"scheduleSystems​","type":1,"pageTitle":"Loop","url":"api/Loop#scheduleSystems","content":"&lt;/&gt; Loop:scheduleSystems( systems: {System}-- Array of systems to schedule. ) → () Schedules a set of systems based on the constraints they define. Systems may optionally declare: The name of the event they run on (e.g., RenderStepped, Stepped, Heartbeat) A numerical priority value Other systems that they must run after If systems do not specify an event, they will run on the default event. Systems that share an event will run in order of their priority, which means that systems with a lower priority value run first. The default priority is 0. Systems that have defined what systems they run after can only be scheduled after all systems they depend on have already been scheduled. All else being equal, the order in which systems run is stable, meaning if you don't change your code, your systems will always run in the same order across machines. info It is possible for your systems to be in an unresolvable state. In which case, scheduleSystems will error. This can happen when your systems have circular or unresolvable dependency chains. If a system has both a priority and defines systems it runs after, the system can only be scheduled if all of the systems it depends on have a lower or equal priority. Systems can never depend on systems that run on other events, because it is not guaranteed or required that events will fire every frame or will always fire in the same order. caution scheduleSystems has to perform nontrivial sorting work each time it's called, so you should avoid calling it multiple times if possible.  "},{"title":"scheduleSystem​","type":1,"pageTitle":"Loop","url":"api/Loop#scheduleSystem","content":"&lt;/&gt; Loop:scheduleSystem(system: System) → () Schedules a single system. This is an expensive function to call multiple times. Instead, try batch scheduling systems with Loop:scheduleSystems if possible.  "},{"title":"evictSystem​","type":1,"pageTitle":"Loop","url":"api/Loop#evictSystem","content":"&lt;/&gt; Loop:evictSystem(system: System) → () Removes a previously-scheduled system from the Loop. Evicting a system also cleans up any storage from hooks. This is intended to be used for hot reloading. Dynamically loading and unloading systems for gameplay logic is not recommended.  "},{"title":"replaceSystem​","type":1,"pageTitle":"Loop","url":"api/Loop#replaceSystem","content":"&lt;/&gt; Loop:replaceSystem( old: System, new: System ) → () Replaces an older version of a system with a newer version of the system. Internal system storage (which is used by hooks) will be moved to be associated with the new system. This is intended to be used for hot reloading.  "},{"title":"begin​","type":1,"pageTitle":"Loop","url":"api/Loop#begin","content":"&lt;/&gt; Loop:begin( events: {[string]: RBXScriptSignal }-- A map from event name to event objects. ) → {[string]: RBXScriptConnection }-- A map from your event names to connection objects. Connects to frame events and starts invoking your systems. Pass a table of events you want to be able to run systems on, a map of name to event. Systems can use these names to define what event they run on. By default, systems run on an event named &quot;default&quot;. Custom events may be used if they have a Connect function. loop:begin({ default = RunService.Heartbeat, Heartbeat = RunService.Heartbeat, RenderStepped = RunService.RenderStepped, Stepped = RunService.Stepped, }) Returns a table similar to the one you passed in, but the values are RBXScriptConnection values (or whatever is returned by :Connect if you passed in a synthetic event).  "},{"title":"addMiddleware​","type":1,"pageTitle":"Loop","url":"api/Loop#addMiddleware","content":"&lt;/&gt; Loop:addMiddleware(middleware: ( nextFn: () → (), eventName: string ) → () → ()) → () Adds a user-defined middleware function that is called during each frame. This allows you to run code before and after each frame, to perform initialization and cleanup work. loop:addMiddleware(function(nextFn) return function() Plasma.start(plasmaNode, nextFn) end end) You must pass addMiddleware a function that itself returns a function that invokes nextFn at some point. The outer function is invoked only once. The inner function is invoked during each frame event. info Middleware added later &quot;wraps&quot; middleware that was added earlier. The innermost middleware function is the internal function that actually calls your systems. "},{"title":"World","type":0,"sectionRef":"#","url":"api/World","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"World","url":"api/World#functions","content":" "},{"title":"new​","type":1,"pageTitle":"World","url":"api/World#new","content":"&lt;/&gt; World.new() → () Creates a new World.  "},{"title":"iterating over World​","type":1,"pageTitle":"World","url":"api/World#__iter","content":"&lt;/&gt; for number, {[Component]: ComponentInstance} in World do Iterates over all entities in this World. Iteration returns entity ID followed by a dictionary mapping Component to Component Instance. Usage: for entityId, entityData in world do print(entityId, entityData[Components.Example]) end   "},{"title":"spawn​","type":1,"pageTitle":"World","url":"api/World#spawn","content":"&lt;/&gt; World:spawn( ...: ComponentInstance-- The component values to spawn the entity with. ) → number-- The new entity ID. Spawns a new entity in the world with the given components.  "},{"title":"spawnAt​","type":1,"pageTitle":"World","url":"api/World#spawnAt","content":"&lt;/&gt; World:spawnAt( id: number,-- The entity ID to spawn with ...: ComponentInstance-- The component values to spawn the entity with. ) → number-- The same entity ID that was passed in Spawns a new entity in the world with a specific entity ID and given components. The next ID generated from World:spawn will be increased as needed to never collide with a manually specified ID.  "},{"title":"replace​","type":1,"pageTitle":"World","url":"api/World#replace","content":"&lt;/&gt; World:replace( id: number,-- The entity ID ...: ComponentInstance-- The component values to spawn the entity with. ) → () Replaces a given entity by ID with an entirely new set of components. Equivalent to removing all components from an entity, and then adding these ones.  "},{"title":"despawn​","type":1,"pageTitle":"World","url":"api/World#despawn","content":"&lt;/&gt; World:despawn( id: number-- The entity ID ) → () Despawns a given entity by ID, removing it and all its components from the world entirely.  "},{"title":"clear​","type":1,"pageTitle":"World","url":"api/World#clear","content":"&lt;/&gt; World:clear() → () Removes all entities from the world. caution Removing entities in this way is not reported by queryChanged.  "},{"title":"contains​","type":1,"pageTitle":"World","url":"api/World#contains","content":"&lt;/&gt; World:contains( id: number-- The entity ID ) → bool-- true if the entity exists Checks if the given entity ID is currently spawned in this world.  "},{"title":"get​","type":1,"pageTitle":"World","url":"api/World#get","content":"&lt;/&gt; World:get( id: number,-- The entity ID ...: Component-- The components to fetch ) → ...-- Returns the component values in the same order they were passed in Gets a specific component (or set of components) from a specific entity in this world.  "},{"title":"query​","type":1,"pageTitle":"World","url":"api/World#query","content":"&lt;/&gt; World:query( ...: Component-- The component types to query. Only entities with all of these components will be returned. ) → QueryResult-- See QueryResult docs. Performs a query against the entities in this World. Returns a QueryResult, which iterates over the results of the query. Order of iteration is not guaranteed. for id, enemy, charge, model in world:query(Enemy, Charge, Model) do -- Do something end for id in world:query(Target):without(Model) do -- Again, with feeling end   "},{"title":"queryChanged​","type":1,"pageTitle":"World","url":"api/World#queryChanged","content":"&lt;/&gt; World:queryChanged( componentToTrack: Component,-- The component you want to listen to changes for. ...: nil ) → () → ( id, ChangeRecord )-- Iterator of entity ID and change record "},{"title":"Types","type":1,"pageTitle":"World","url":"api/World##","content":""},{"title":"​","type":1,"pageTitle":"World","url":"api/World#ChangeRecord","content":"interface ChangeRecord { new?: ComponentInstance-- The new value of the component. Nil if just removed. old?: ComponentInstance-- The former value of the component. Nil if just added. }   Topologically-aware function This function is only usable if called within the context of Loop:begin. Queries for components that have changed since the last time your system ran queryChanged. Only one changed record is returned per entity, even if the same entity changed multiple times. The order in which changed records are returned is not guaranteed to be the order that the changes occurred in. It should be noted that queryChanged does not have the same iterator invalidation concerns as World:query. caution The first time your system runs (i.e., on the first frame), no results are returned. Results only begin to be tracked after the first time your system calls this function. info Calling this function from your system creates storage internally for your system. Then, changes meeting your criteria are pushed into your storage. Calling queryChanged again each frame drains this storage. If your system isn't called every frame, the storage will continually fill up and does not empty unless you drain it. If you stop calling queryChanged in your system, changes will stop being tracked. Returns queryChanged returns an iterator function, so you call it in a for loop just like World:query. The iterator returns the entity ID, followed by a ChangeRecord. The ChangeRecord type is a table that contains two fields, new and old, respectively containing the new component instance, and the old component instance. new and old will never be the same value. new will be nil if the component was removed (or the entity was despawned), and old will be nil if the component was just added. The old field will be the value of the component the last time this system observed it, not necessarily the value it changed from most recently. The ChangeRecord table is potentially shared with multiple systems tracking changes for this component, so it cannot be modified. for id, record in world:queryChanged(Model) do if record.new == nil then -- Model was removed if enemy.type == &quot;this is a made up example&quot; then world:remove(id, Enemy) end end end   "},{"title":"insert​","type":1,"pageTitle":"World","url":"api/World#insert","content":"&lt;/&gt; World:insert( id: number,-- The entity ID ...: ComponentInstance-- The component values to insert ) → () Inserts a component (or set of components) into an existing entity. If another instance of a given component already exists on this entity, it is replaced. world:insert( entityId, ComponentA({ foo = &quot;bar&quot; }), ComponentB({ baz = &quot;qux&quot; }) )   "},{"title":"remove​","type":1,"pageTitle":"World","url":"api/World#remove","content":"&lt;/&gt; World:remove( id: number,-- The entity ID ...: Component-- The components to remove ) → ...ComponentInstance-- Returns the component instance values that were removed in the order they were passed. Removes a component (or set of components) from an existing entity. local removedA, removedB = world:remove(entityId, ComponentA, ComponentB)   "},{"title":"size​","type":1,"pageTitle":"World","url":"api/World#size","content":"&lt;/&gt; World:size() → () Returns the number of entities currently spawned in the world.  "},{"title":"optimizeQueries​","type":1,"pageTitle":"World","url":"api/World#optimizeQueries","content":"&lt;/&gt; World:optimizeQueries() → ()  tip Loop automatically calls this function on your World(s), so there is no need to call it yourself if you're using a Loop. If you are not using a Loop, you should call this function at a regular interval (i.e., once per frame) to optimize the internal storage for queries. This is part of a strategy to eliminate iterator invalidation when modifying the World while inside a query fromWorld:query. While inside a query, any changes to the World are stored in a separate location from the rest of the World. Calling this function combines the separate storage back into the main storage, which speeds things up again. "}]